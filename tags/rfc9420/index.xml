<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Rfc9420 on OpenMLS</title><link>https://blog.openmls.tech/tags/rfc9420/</link><description>Recent content in Rfc9420 on OpenMLS</description><generator>Hugo -- 0.156.0</generator><language>en-us</language><managingEditor>hello@openmls.tech (OpenMLS)</managingEditor><webMaster>hello@openmls.tech (OpenMLS)</webMaster><lastBuildDate>Mon, 30 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.openmls.tech/tags/rfc9420/index.xml" rel="self" type="application/rss+xml"/><item><title>Taking Stock of Validation Checks</title><link>https://blog.openmls.tech/posts/2024-09-30-taking-stock-of-validation-checks/</link><pubDate>Mon, 30 Sep 2024 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2024-09-30-taking-stock-of-validation-checks/</guid><description>&lt;p&gt;When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks&amp;hellip; all kinds of vulnerabilities.&lt;/p&gt;
&lt;p&gt;To give an example, you might remember &lt;a href="https://www.imperialviolet.org/2014/02/22/applebug.html"&gt;the &amp;ldquo;goto fail&amp;rdquo; vulnerability&lt;/a&gt;, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the &lt;code&gt;ServerKeyExchange&lt;/code&gt; message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn&amp;rsquo;t just &lt;em&gt;forget&lt;/em&gt; to do the check, it does demonstrate why these checks are important.&lt;/p&gt;</description><content:encoded><![CDATA[<p>When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks&hellip; all kinds of vulnerabilities.</p>
<p>To give an example, you might remember <a href="https://www.imperialviolet.org/2014/02/22/applebug.html">the &ldquo;goto fail&rdquo; vulnerability</a>, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the <code>ServerKeyExchange</code> message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn&rsquo;t just <em>forget</em> to do the check, it does demonstrate why these checks are important.</p>
<p>In the context of MLS, consider what would happen if we didn&rsquo;t do the <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2-2.3">check</a> that validates the signature over <code>FramedContent</code> objects, which wrap the relevant parts of MLS messages to provide authentication. An attacker could change the sender field of <code>FramedContent</code> to a different member and we wouldn&rsquo;t notice, because we don&rsquo;t get an error when trying to validate the signature with that other member&rsquo;s public key.</p>
<p>This is a drastic example of course, and it&rsquo;s unlikely one would forget to implement this particular check. However, MLS is a large complex protocol and there are a lot of these checks in the MLS RFC that need to be done by OpenMLS (we counted 50 so far). The good news is that the RFC lays them all out. The bad news is that they are somewhat scattered across the document and there is no good overview.</p>
<p>In addition, the way the RFC abstracts away delivery and authentication also means that it is not always obvious whether a check would need to happen inside the client implementation (e.g. <a href="https://github.com/openmls/openmls">OpenMLS</a>), the Delivery Service or the Authentication Service. This means that understanding whether a check has to be done inside or outside of OpenMLS is not always straightforward. And while in theory it is enough that all the checks are in the code, in practice it&rsquo;s also important to test that all the checks are being performed, so they don&rsquo;t accidentally get removed or circumvented in a refactor years later.</p>
<p>We knew we needed some sort of list or database of checks. This raised two questions: What sort of data do we want to keep, and how do we structure it? What is the format of the list?</p>
<h1 id="the-data-we-need">The Data We Need</h1>
<p>Let&rsquo;s look at the data first. The main information we want to capture are checks, and each check consists of an ID, a text quoted from and linking to the RFC text, and some way of referring to the code where the check is implemented and tested. We are still experimenting with that last part, but for now we have settled on keeping the modpath of the function we refer to, as well as a permalink to the specific part of the code. We also mention the check ID in the code, so that can also be searched for.</p>
<p>Most validation checks belong to a group of checks that are performed together, and we would like to maintain that grouping, so each &ldquo;check&rdquo; is part of a &ldquo;check set&rdquo;. The check set also provides some context for the check. So a check set consists of another RFC quote (with link) and a list of checks.</p>
<h1 id="the-format-we-keep-it-in">The Format We Keep It In</h1>
<p>As for the formats, we wanted a uniform structure, and we want it to be relatively simple to update. And, maybe most importantly, we want to be able to look at and understand what we are missing. Let&rsquo;s first look at what we thought didn&rsquo;t work very well:</p>
<ul>
<li>A large text file (or md/html file, or a google doc) that we manually edit to render to a nice visual overview seems difficult to maintain</li>
<li>The fact that some of the items each check carries are lists, makes using anything that resembles spreadsheets or CSV-files pretty awkward to use</li>
</ul>
<p>The obvious third choice would be a JSON file that contains an array of check sets. We could then write a tool that generates an HTML file providing an overview over the checks from the JSON. However, this would mean everything is in a single large file, and modifying that by hand seems pretty error-prone. YAML might be a bit nicer to write, but is also error-prone. It would be nice if we had a language that was a bit like JSON, but nicer to write and with strong types, to catch errors early.</p>
<p>I had heard of the <a href="https://dhall-lang.org/">Dhall language</a> before and while it always sounded interesting, I never had use for it. It&rsquo;s a small programming language that mostly seems to be intended for generating config files. The idea is that it enforces termination and handling of all possible inputs. This means it can&rsquo;t hang or error out because the program doesn&rsquo;t handle an edge case. This seemed like an interesting option, and the fact that one of the main features of Dhall is that it can easily produce a JSON representation of the contained data, it would be easy to pivot to a different format if Dhall would turn out to not work well for us.</p>
<p>We followed a pretty boring structure: In one file we define the domain types (e.g. <code>Check</code>, <code>CheckSet</code>, ), in another file we generate HTML for the domain types. We also have a folder that contains one check set per file and a file that bundles all the check sets into a single place that can be processed. These all behave a bit like libraries. We then have a file that imports the check sets and the code generating the HTML and returns a string containing the dashboard, which looks like <a href="https://validation.openmls.tech">this</a>.</p>
<h1 id="an-example">An example</h1>
<p>Let&rsquo;s go back to the <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2-2.3">check</a> we looked at earlier. The check is part of a <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2">section</a> that describes what need to be checked when validating a commit. In our dashboard, we made that whole section a <a href="https://validation.openmls.tech/#cs12">check set</a>, and at the time of writing it looks like this:</p>
<figure><a href="validation_dashboard.png">
    <img loading="lazy" src="validation_dashboard.png"/> </a><figcaption>
            Validation Dashboard
        </figcaption>
</figure>

<p>The check set starts with quotes from the RFC and links to the places in the RFC that the quotes come from. It is followed by a table of checks. Each check has an identifier for the check, if we want to reference it in text. We then have the text from the RFC and a link to the specific paragraph of the RFC that contains the text. In the rightmost column we have a link to a search for the check ID in the OpenMLS repository on Github, some notes as well as references to the implementation of the check and tests for the check (if available). Links into the code show modpath of the linked function but link to the permalink to the specific lines of code where a check is implemented or tested. The pilcrows (¬∂) link to the check set or check itself, to make it easier to link it elsewere.</p>
<p>For example, the <a href="https://validation.openmls.tech/#cs12">check set for commits</a> contains check <a href="https://validation.openmls.tech/#valn1203">valn1203</a>, which has a link to the RFC at exactly the <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2-2.3">right place</a>, as well as links to the <a href="https://github.com/openmls/openmls/blob/5067034708f2332b0dfd8d7d28eb6618fd38f4c7/openmls/src/group/mls_group/processing.rs#L273-L274">places</a> <a href="https://github.com/openmls/openmls/blob/5067034708f2332b0dfd8d7d28eb6618fd38f4c7/openmls/src/group/public_group/process.rs#L203-L204">where</a> the check is implemented. We don&rsquo;t have links to where we test that the check is done correctly, that&rsquo;s why there are no test refs, and that&rsquo;s also why the status of that check is <em>Partial</em> instead of <em>Complete</em>.</p>
<p>The nice thing about having the data in a machine-readable format is that we can also do other things with it. For example, we generate a bookmarklet (a little snippet of JS that is stored in a bookmark) that when it is clicked while browsing the RFC, it highlights all the parts of the RFC that have already been captured in the database. This helps with searching the RFC for checks we missed. In the future, we could also generate a dashboard that has its focus on the checks that are not completely implemented or tested yet. Try it, it&rsquo;s <a href="https://validation.openmls.tech/bookmarklet.html">here</a>.</p>
<h1 id="learnings">Learnings</h1>
<p>Overall, Dhall works pretty well for us. There are some warts, such as not-very-helpful syntax error messages, the linter sometimes removing comments as well as documentation sometimes being a bit confusing and spread across several places, but it was reasonably easy to set up something that works and does the job reliably.</p>
<p>Another thing we haven&rsquo;t completely figured out yet is how to best link into the code. Linking to source code lines at specific commits means we can link to specific lines, but also that links will quickly go out-of-date. Using Rust modpaths is more stable, in the sense that the path correctly identifies a piece of code across commits (unless you refactor). On the other hand, they are more granular (you can only reference functions) and there is no tooling for using them as hyperlinks. Also, it&rsquo;s unclear how to deal with aliases and visibility. Because we were not sure what the right thing to do is here, we do both for now. On top of that, we added a link to search the source code for the ID of the check, to quickly find mentions in comments and function names. However, this requires being logged into Github and only works on the current main branch.</p>
<h1 id="next-steps">Next Steps</h1>
<p>But now, the real work starts: Double-checking that we captured all the checks that we need to do, and making sure that we actually do all the checks, and properly test them. And while all that is going on, we are getting a better understanding of what we really need and how we can improve the dashboard.</p>
<p>We started adding <a href="https://github.com/openmls/openmls/pull/1655">missing checks</a> and will continue doing so until all checks are implemented and tested.</p>
<p>In future we will also prove that all required checks have been performed. Stay tuned for more on this soon.</p>
]]></content:encoded></item><item><title>OpenMLS 0.6 released</title><link>https://blog.openmls.tech/posts/2024-09-04-v0_6-release/</link><pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2024-09-04-v0_6-release/</guid><description>&lt;p&gt;Today, we are releasing version 0.6 of OpenMLS. In this post we‚Äôll go over the most significant changes since our last release.&lt;/p&gt;
&lt;h1 id="new-storage-provider"&gt;New Storage Provider&lt;/h1&gt;
&lt;p&gt;To make it easier to persist group state, the &lt;code&gt;KeyStoreProvider&lt;/code&gt; was replaced with the more powerful &lt;code&gt;StorageProvider&lt;/code&gt; trait for tracking the state of a group or a party. This includes keys, but also other group state like the ratchet tree and the group context. OpenMLS writes to the storage at the end of any successful operation. This means that if the provider is backed by some persistent memory, the entire long-lived state of OpenMLS is automatically persisted.&lt;/p&gt;</description><content:encoded><![CDATA[<p>Today, we are releasing version 0.6 of OpenMLS. In this post we‚Äôll go over the most significant changes since our last release.</p>
<h1 id="new-storage-provider">New Storage Provider</h1>
<p>To make it easier to persist group state, the <code>KeyStoreProvider</code> was replaced with the more powerful <code>StorageProvider</code> trait for tracking the state of a group or a party. This includes keys, but also other group state like the ratchet tree and the group context. OpenMLS writes to the storage at the end of any successful operation. This means that if the provider is backed by some persistent memory, the entire long-lived state of OpenMLS is automatically persisted.</p>
<p>üîó <a href="https://github.com/openmls/openmls/pull/1565">Github PR</a><br>
üîó <a href="https://book.openmls.tech/traits/traits.html#storageprovider">Documentation</a></p>
<h1 id="api-changes">API Changes</h1>
<p>In an effort to make OpenMLS as easy to use as possible, we made some API changes to rid of a few footguns and provide better ergonomics.</p>
<h2 id="a-staged-api-for-welcomes">A Staged API for Welcomes</h2>
<p>In the old API, it was not possible to inspect the details of a group one is invited to without joining it. There was a workaround, but v0.6 solves the problem cleanly by making joining from a Welcome message a two-stage process: First the welcome is parsed and decrypted into a <code>StagedWelcome</code>. This value can be used for inspecting the group, and then turned into a full <code>MlsGroup</code>.</p>
<p>üîó <a href="https://github.com/openmls/openmls/issues/1508">Github Issue</a><br>
üîó <a href="https://book.openmls.tech/user_manual/join_from_welcome.html">Documentation</a></p>
<h2 id="split-group-configuration-into-separate-types">Split Group Configuration into separate types</h2>
<p>The <code>MlsGroupConfig</code> struct was needed both for creating a new group and for joining an existing one from a Welcome message. We replaced it with the two structs <code>MlsGroupCreateConfig</code> and <code>MlsGroupJoinConfig</code>. This removes the somewhat awkward situation that, when joining a group, the user could set config items that are only relevant to creating the group.</p>
<p>üîó <a href="https://github.com/openmls/openmls/pull/1464">Github PR</a></p>
<h2 id="a-clean-way-to-update-the-own-leaf-node">A Clean Way to Update the Own Leaf Node</h2>
<p>The way we handled the creation of self-update proposals was not ideal, and required us to modify the leaf node that was passed into the <code>propose_self_update</code> function. We did an overhaul of the API here and now instead pass in the information that is required to build the new leaf node (in the form of <code>LeafNodeParameters</code>), which is then created by the <code>propose_self_update</code> itself.</p>
<p>üîó <a href="https://github.com/openmls/openmls/pull/1606">Github PR</a></p>
<h2 id="builders-builders-more-builders">Builders, Builders, more Builders</h2>
<p>We added builders for many more types to make them more easily constructible:</p>
<ul>
<li><code>MlsGroup</code></li>
<li><code>KeyPackage</code></li>
<li><code>Capabilities</code></li>
<li><code>LeafNodeParameters</code></li>
</ul>
<h2 id="libcrux-crypto-provider-and-post-quantum-ciphersuite">Libcrux Crypto Provider and Post-Quantum Ciphersuite</h2>
<p>We added a second crypto provider, that is (for the most part) backed by libcrux instead of the RustCrypto crates. Libcrux is a high-assurance cryptographic library, which means it uses formal methods to achieve higher confidence in the correctness of the implementation.</p>
<p>Libcrux also contains code for Kyber/ML-KEM, a public key encryption algorithm that is designed to be resistant against quantum computer attacks. We provide a ciphersuite using it in hybrid mode (i.e. together with a more established public key algorithm known to be secure against attacks with classical computers) using the XWing combiner</p>
<p>üîó <a href="https://blog.openmls.tech/posts/2024-04-11-pq-openmls/">Blog Post</a></p>
<h1 id="progress-on-long-term-efforts">Progress on Long-Term Efforts</h1>
<p>We started an effort to make sure that we do all the validation checks mandated by the RFC, and we do and test them. For this, we started making <a href="https://github.com/openmls/validation.dhall">a machine-readable list</a> of all the checks, and generating an <a href="https://validation.openmls.tech">HTML dashboard</a>. We started writing some new tests and referencing them in the dashboard.</p>
<p>We also started some refactoring around the group state. There was a historic distinction between MlsGroup and CoreGroup. This distinction is making increasingly little sense, and we are in an effort to merge the two. However, since this is a core piece of the library, doing it all at once would be a very large change that may introduce a number of new bugs. In the spirit of ‚Äúfirst make the change easy, then make the easy change‚Äù, we decided this should be a longer-term transition. We made some progress already, but CoreGroup will stick around for a little longer.</p>
<p>Another area we made a little progress in is Wasm support. In order to keep an eye on the Wasm binary size of the OpenMLS library, we added a build on CI for some minimal Wasm bindings and fail if the gzip-compressed binary is larger than 500 kB. This means that while it will add considerable page load cost, OpenMLS can be used on the web today!</p>
]]></content:encoded></item><item><title>OpenMLS 0.5 released</title><link>https://blog.openmls.tech/posts/2023-07-20-v0_5-release/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2023-07-20-v0_5-release/</guid><description>&lt;p&gt;Today, we are releasing OpenMLS v0.5. This release has been a while in the making and covers substantial changes since the last release. We are grateful for &lt;a href="https://openmls.tech/blog/2022-10-19-update/"&gt;the support of the Sovereign Tech Fund&lt;/a&gt; towards this goal. These are some of the changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The implementation caught up with the latest changes in the protocol specification. The last version was roughly based on draft 12. Since then, the protocol has iteratively evolved all the way through draft 20. The library now implements the wire format of messages and mechanisms specified in &lt;a href="https://datatracker.ietf.org/doc/html/rfc9420"&gt;RFC 9420&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Extensive &lt;a href="https://github.com/mlswg/mls-implementations"&gt;interoperability testing&lt;/a&gt; has been done between OpenMLS, Cisco‚Äôs MLS++, and another closed-source MLS protocol implementation. The goal of this exercise was to validate the last set of changes in the specification and ascertain that all implementations implemented the specification correctly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="the-next-phase"&gt;The next phase&lt;/h1&gt;
&lt;p&gt;Until recently, the specification was a moving target and so was the implementation. Now that the specification is no longer subject to changes, the implementation can finally mature in terms of correctness, ease-of-use, and efficiency.
We would like OpenMLS to be as useful as possible to those who consider end-to-end encryption with MLS. We are ready to evolve the library in the following areas:&lt;/p&gt;</description><content:encoded><![CDATA[<p>Today, we are releasing OpenMLS v0.5. This release has been a while in the making and covers substantial changes since the last release. We are grateful for <a href="https://openmls.tech/blog/2022-10-19-update/">the support of the Sovereign Tech Fund</a> towards this goal. These are some of the changes:</p>
<ul>
<li>The implementation caught up with the latest changes in the protocol specification. The last version was roughly based on draft 12. Since then, the protocol has iteratively evolved all the way through draft 20. The library now implements the wire format of messages and mechanisms specified in <a href="https://datatracker.ietf.org/doc/html/rfc9420">RFC 9420</a>.</li>
<li>Extensive <a href="https://github.com/mlswg/mls-implementations">interoperability testing</a> has been done between OpenMLS, Cisco‚Äôs MLS++, and another closed-source MLS protocol implementation. The goal of this exercise was to validate the last set of changes in the specification and ascertain that all implementations implemented the specification correctly.</li>
</ul>
<h1 id="the-next-phase">The next phase</h1>
<p>Until recently, the specification was a moving target and so was the implementation. Now that the specification is no longer subject to changes, the implementation can finally mature in terms of correctness, ease-of-use, and efficiency.
We would like OpenMLS to be as useful as possible to those who consider end-to-end encryption with MLS. We are ready to evolve the library in the following areas:</p>
<ul>
<li>Stabilize the persistence format</li>
<li>Improve and harmonize the API</li>
<li>Improve efficiency</li>
<li>Support new platforms</li>
<li>Add optional features and extensions</li>
</ul>
<h1 id="looking-for-help">Looking for help?</h1>
<p>If you are looking to use OpenMLS in your project the OpenMLS team can offer professional help with consulting or with implementing. We can accelerate the development of the items listed above or offer a more bespoke solution. Drop us an email at <a href="mailto:hello@openmls.tech">hello@openmls.tech</a>.</p>
]]></content:encoded></item></channel></rss>