<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Mls on OpenMLS</title><link>https://blog.openmls.tech/tags/mls/</link><description>Recent content in Mls on OpenMLS</description><generator>Hugo -- 0.156.0</generator><language>en-us</language><managingEditor>hello@openmls.tech (OpenMLS)</managingEditor><webMaster>hello@openmls.tech (OpenMLS)</webMaster><lastBuildDate>Mon, 30 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.openmls.tech/tags/mls/index.xml" rel="self" type="application/rss+xml"/><item><title>Taking Stock of Validation Checks</title><link>https://blog.openmls.tech/posts/2024-09-30-taking-stock-of-validation-checks/</link><pubDate>Mon, 30 Sep 2024 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2024-09-30-taking-stock-of-validation-checks/</guid><description>&lt;p&gt;When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks&amp;hellip; all kinds of vulnerabilities.&lt;/p&gt;
&lt;p&gt;To give an example, you might remember &lt;a href="https://www.imperialviolet.org/2014/02/22/applebug.html"&gt;the &amp;ldquo;goto fail&amp;rdquo; vulnerability&lt;/a&gt;, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the &lt;code&gt;ServerKeyExchange&lt;/code&gt; message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn&amp;rsquo;t just &lt;em&gt;forget&lt;/em&gt; to do the check, it does demonstrate why these checks are important.&lt;/p&gt;</description><content:encoded><![CDATA[<p>When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks&hellip; all kinds of vulnerabilities.</p>
<p>To give an example, you might remember <a href="https://www.imperialviolet.org/2014/02/22/applebug.html">the &ldquo;goto fail&rdquo; vulnerability</a>, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the <code>ServerKeyExchange</code> message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn&rsquo;t just <em>forget</em> to do the check, it does demonstrate why these checks are important.</p>
<p>In the context of MLS, consider what would happen if we didn&rsquo;t do the <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2-2.3">check</a> that validates the signature over <code>FramedContent</code> objects, which wrap the relevant parts of MLS messages to provide authentication. An attacker could change the sender field of <code>FramedContent</code> to a different member and we wouldn&rsquo;t notice, because we don&rsquo;t get an error when trying to validate the signature with that other member&rsquo;s public key.</p>
<p>This is a drastic example of course, and it&rsquo;s unlikely one would forget to implement this particular check. However, MLS is a large complex protocol and there are a lot of these checks in the MLS RFC that need to be done by OpenMLS (we counted 50 so far). The good news is that the RFC lays them all out. The bad news is that they are somewhat scattered across the document and there is no good overview.</p>
<p>In addition, the way the RFC abstracts away delivery and authentication also means that it is not always obvious whether a check would need to happen inside the client implementation (e.g. <a href="https://github.com/openmls/openmls">OpenMLS</a>), the Delivery Service or the Authentication Service. This means that understanding whether a check has to be done inside or outside of OpenMLS is not always straightforward. And while in theory it is enough that all the checks are in the code, in practice it&rsquo;s also important to test that all the checks are being performed, so they don&rsquo;t accidentally get removed or circumvented in a refactor years later.</p>
<p>We knew we needed some sort of list or database of checks. This raised two questions: What sort of data do we want to keep, and how do we structure it? What is the format of the list?</p>
<h1 id="the-data-we-need">The Data We Need</h1>
<p>Let&rsquo;s look at the data first. The main information we want to capture are checks, and each check consists of an ID, a text quoted from and linking to the RFC text, and some way of referring to the code where the check is implemented and tested. We are still experimenting with that last part, but for now we have settled on keeping the modpath of the function we refer to, as well as a permalink to the specific part of the code. We also mention the check ID in the code, so that can also be searched for.</p>
<p>Most validation checks belong to a group of checks that are performed together, and we would like to maintain that grouping, so each &ldquo;check&rdquo; is part of a &ldquo;check set&rdquo;. The check set also provides some context for the check. So a check set consists of another RFC quote (with link) and a list of checks.</p>
<h1 id="the-format-we-keep-it-in">The Format We Keep It In</h1>
<p>As for the formats, we wanted a uniform structure, and we want it to be relatively simple to update. And, maybe most importantly, we want to be able to look at and understand what we are missing. Let&rsquo;s first look at what we thought didn&rsquo;t work very well:</p>
<ul>
<li>A large text file (or md/html file, or a google doc) that we manually edit to render to a nice visual overview seems difficult to maintain</li>
<li>The fact that some of the items each check carries are lists, makes using anything that resembles spreadsheets or CSV-files pretty awkward to use</li>
</ul>
<p>The obvious third choice would be a JSON file that contains an array of check sets. We could then write a tool that generates an HTML file providing an overview over the checks from the JSON. However, this would mean everything is in a single large file, and modifying that by hand seems pretty error-prone. YAML might be a bit nicer to write, but is also error-prone. It would be nice if we had a language that was a bit like JSON, but nicer to write and with strong types, to catch errors early.</p>
<p>I had heard of the <a href="https://dhall-lang.org/">Dhall language</a> before and while it always sounded interesting, I never had use for it. It&rsquo;s a small programming language that mostly seems to be intended for generating config files. The idea is that it enforces termination and handling of all possible inputs. This means it can&rsquo;t hang or error out because the program doesn&rsquo;t handle an edge case. This seemed like an interesting option, and the fact that one of the main features of Dhall is that it can easily produce a JSON representation of the contained data, it would be easy to pivot to a different format if Dhall would turn out to not work well for us.</p>
<p>We followed a pretty boring structure: In one file we define the domain types (e.g. <code>Check</code>, <code>CheckSet</code>, ), in another file we generate HTML for the domain types. We also have a folder that contains one check set per file and a file that bundles all the check sets into a single place that can be processed. These all behave a bit like libraries. We then have a file that imports the check sets and the code generating the HTML and returns a string containing the dashboard, which looks like <a href="https://validation.openmls.tech">this</a>.</p>
<h1 id="an-example">An example</h1>
<p>Let&rsquo;s go back to the <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2-2.3">check</a> we looked at earlier. The check is part of a <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2">section</a> that describes what need to be checked when validating a commit. In our dashboard, we made that whole section a <a href="https://validation.openmls.tech/#cs12">check set</a>, and at the time of writing it looks like this:</p>
<figure><a href="validation_dashboard.png">
    <img loading="lazy" src="validation_dashboard.png"/> </a><figcaption>
            Validation Dashboard
        </figcaption>
</figure>

<p>The check set starts with quotes from the RFC and links to the places in the RFC that the quotes come from. It is followed by a table of checks. Each check has an identifier for the check, if we want to reference it in text. We then have the text from the RFC and a link to the specific paragraph of the RFC that contains the text. In the rightmost column we have a link to a search for the check ID in the OpenMLS repository on Github, some notes as well as references to the implementation of the check and tests for the check (if available). Links into the code show modpath of the linked function but link to the permalink to the specific lines of code where a check is implemented or tested. The pilcrows (¬∂) link to the check set or check itself, to make it easier to link it elsewere.</p>
<p>For example, the <a href="https://validation.openmls.tech/#cs12">check set for commits</a> contains check <a href="https://validation.openmls.tech/#valn1203">valn1203</a>, which has a link to the RFC at exactly the <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2-2.3">right place</a>, as well as links to the <a href="https://github.com/openmls/openmls/blob/5067034708f2332b0dfd8d7d28eb6618fd38f4c7/openmls/src/group/mls_group/processing.rs#L273-L274">places</a> <a href="https://github.com/openmls/openmls/blob/5067034708f2332b0dfd8d7d28eb6618fd38f4c7/openmls/src/group/public_group/process.rs#L203-L204">where</a> the check is implemented. We don&rsquo;t have links to where we test that the check is done correctly, that&rsquo;s why there are no test refs, and that&rsquo;s also why the status of that check is <em>Partial</em> instead of <em>Complete</em>.</p>
<p>The nice thing about having the data in a machine-readable format is that we can also do other things with it. For example, we generate a bookmarklet (a little snippet of JS that is stored in a bookmark) that when it is clicked while browsing the RFC, it highlights all the parts of the RFC that have already been captured in the database. This helps with searching the RFC for checks we missed. In the future, we could also generate a dashboard that has its focus on the checks that are not completely implemented or tested yet. Try it, it&rsquo;s <a href="https://validation.openmls.tech/bookmarklet.html">here</a>.</p>
<h1 id="learnings">Learnings</h1>
<p>Overall, Dhall works pretty well for us. There are some warts, such as not-very-helpful syntax error messages, the linter sometimes removing comments as well as documentation sometimes being a bit confusing and spread across several places, but it was reasonably easy to set up something that works and does the job reliably.</p>
<p>Another thing we haven&rsquo;t completely figured out yet is how to best link into the code. Linking to source code lines at specific commits means we can link to specific lines, but also that links will quickly go out-of-date. Using Rust modpaths is more stable, in the sense that the path correctly identifies a piece of code across commits (unless you refactor). On the other hand, they are more granular (you can only reference functions) and there is no tooling for using them as hyperlinks. Also, it&rsquo;s unclear how to deal with aliases and visibility. Because we were not sure what the right thing to do is here, we do both for now. On top of that, we added a link to search the source code for the ID of the check, to quickly find mentions in comments and function names. However, this requires being logged into Github and only works on the current main branch.</p>
<h1 id="next-steps">Next Steps</h1>
<p>But now, the real work starts: Double-checking that we captured all the checks that we need to do, and making sure that we actually do all the checks, and properly test them. And while all that is going on, we are getting a better understanding of what we really need and how we can improve the dashboard.</p>
<p>We started adding <a href="https://github.com/openmls/openmls/pull/1655">missing checks</a> and will continue doing so until all checks are implemented and tested.</p>
<p>In future we will also prove that all required checks have been performed. Stay tuned for more on this soon.</p>
]]></content:encoded></item><item><title>OpenMLS 0.6 released</title><link>https://blog.openmls.tech/posts/2024-09-04-v0_6-release/</link><pubDate>Wed, 04 Sep 2024 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2024-09-04-v0_6-release/</guid><description>&lt;p&gt;Today, we are releasing version 0.6 of OpenMLS. In this post we‚Äôll go over the most significant changes since our last release.&lt;/p&gt;
&lt;h1 id="new-storage-provider"&gt;New Storage Provider&lt;/h1&gt;
&lt;p&gt;To make it easier to persist group state, the &lt;code&gt;KeyStoreProvider&lt;/code&gt; was replaced with the more powerful &lt;code&gt;StorageProvider&lt;/code&gt; trait for tracking the state of a group or a party. This includes keys, but also other group state like the ratchet tree and the group context. OpenMLS writes to the storage at the end of any successful operation. This means that if the provider is backed by some persistent memory, the entire long-lived state of OpenMLS is automatically persisted.&lt;/p&gt;</description><content:encoded><![CDATA[<p>Today, we are releasing version 0.6 of OpenMLS. In this post we‚Äôll go over the most significant changes since our last release.</p>
<h1 id="new-storage-provider">New Storage Provider</h1>
<p>To make it easier to persist group state, the <code>KeyStoreProvider</code> was replaced with the more powerful <code>StorageProvider</code> trait for tracking the state of a group or a party. This includes keys, but also other group state like the ratchet tree and the group context. OpenMLS writes to the storage at the end of any successful operation. This means that if the provider is backed by some persistent memory, the entire long-lived state of OpenMLS is automatically persisted.</p>
<p>üîó <a href="https://github.com/openmls/openmls/pull/1565">Github PR</a><br>
üîó <a href="https://book.openmls.tech/traits/traits.html#storageprovider">Documentation</a></p>
<h1 id="api-changes">API Changes</h1>
<p>In an effort to make OpenMLS as easy to use as possible, we made some API changes to rid of a few footguns and provide better ergonomics.</p>
<h2 id="a-staged-api-for-welcomes">A Staged API for Welcomes</h2>
<p>In the old API, it was not possible to inspect the details of a group one is invited to without joining it. There was a workaround, but v0.6 solves the problem cleanly by making joining from a Welcome message a two-stage process: First the welcome is parsed and decrypted into a <code>StagedWelcome</code>. This value can be used for inspecting the group, and then turned into a full <code>MlsGroup</code>.</p>
<p>üîó <a href="https://github.com/openmls/openmls/issues/1508">Github Issue</a><br>
üîó <a href="https://book.openmls.tech/user_manual/join_from_welcome.html">Documentation</a></p>
<h2 id="split-group-configuration-into-separate-types">Split Group Configuration into separate types</h2>
<p>The <code>MlsGroupConfig</code> struct was needed both for creating a new group and for joining an existing one from a Welcome message. We replaced it with the two structs <code>MlsGroupCreateConfig</code> and <code>MlsGroupJoinConfig</code>. This removes the somewhat awkward situation that, when joining a group, the user could set config items that are only relevant to creating the group.</p>
<p>üîó <a href="https://github.com/openmls/openmls/pull/1464">Github PR</a></p>
<h2 id="a-clean-way-to-update-the-own-leaf-node">A Clean Way to Update the Own Leaf Node</h2>
<p>The way we handled the creation of self-update proposals was not ideal, and required us to modify the leaf node that was passed into the <code>propose_self_update</code> function. We did an overhaul of the API here and now instead pass in the information that is required to build the new leaf node (in the form of <code>LeafNodeParameters</code>), which is then created by the <code>propose_self_update</code> itself.</p>
<p>üîó <a href="https://github.com/openmls/openmls/pull/1606">Github PR</a></p>
<h2 id="builders-builders-more-builders">Builders, Builders, more Builders</h2>
<p>We added builders for many more types to make them more easily constructible:</p>
<ul>
<li><code>MlsGroup</code></li>
<li><code>KeyPackage</code></li>
<li><code>Capabilities</code></li>
<li><code>LeafNodeParameters</code></li>
</ul>
<h2 id="libcrux-crypto-provider-and-post-quantum-ciphersuite">Libcrux Crypto Provider and Post-Quantum Ciphersuite</h2>
<p>We added a second crypto provider, that is (for the most part) backed by libcrux instead of the RustCrypto crates. Libcrux is a high-assurance cryptographic library, which means it uses formal methods to achieve higher confidence in the correctness of the implementation.</p>
<p>Libcrux also contains code for Kyber/ML-KEM, a public key encryption algorithm that is designed to be resistant against quantum computer attacks. We provide a ciphersuite using it in hybrid mode (i.e. together with a more established public key algorithm known to be secure against attacks with classical computers) using the XWing combiner</p>
<p>üîó <a href="https://blog.openmls.tech/posts/2024-04-11-pq-openmls/">Blog Post</a></p>
<h1 id="progress-on-long-term-efforts">Progress on Long-Term Efforts</h1>
<p>We started an effort to make sure that we do all the validation checks mandated by the RFC, and we do and test them. For this, we started making <a href="https://github.com/openmls/validation.dhall">a machine-readable list</a> of all the checks, and generating an <a href="https://validation.openmls.tech">HTML dashboard</a>. We started writing some new tests and referencing them in the dashboard.</p>
<p>We also started some refactoring around the group state. There was a historic distinction between MlsGroup and CoreGroup. This distinction is making increasingly little sense, and we are in an effort to merge the two. However, since this is a core piece of the library, doing it all at once would be a very large change that may introduce a number of new bugs. In the spirit of ‚Äúfirst make the change easy, then make the easy change‚Äù, we decided this should be a longer-term transition. We made some progress already, but CoreGroup will stick around for a little longer.</p>
<p>Another area we made a little progress in is Wasm support. In order to keep an eye on the Wasm binary size of the OpenMLS library, we added a build on CI for some minimal Wasm bindings and fail if the gzip-compressed binary is larger than 500 kB. This means that while it will add considerable page load cost, OpenMLS can be used on the web today!</p>
]]></content:encoded></item><item><title>Post-Quantum OpenMLS</title><link>https://blog.openmls.tech/posts/2024-04-11-pq-openmls/</link><pubDate>Thu, 11 Apr 2024 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2024-04-11-pq-openmls/</guid><description>Get started with post-quantum secure end-to-end encrypted with OpenMLS.</description><content:encoded><![CDATA[<p>OpenMLS now offers security against harvest-now-decrypt-later (HNDL) quantum adversaries.</p>
<p>In <a href="https://github.com/openmls/openmls/pull/1546">#1546</a> we merged support for the <a href="https://www.ietf.org/archive/id/draft-connolly-cfrg-xwing-kem-02.html">X-Wing KEM draft</a>, which is an early draft for securely combining elliptic-curve-based Diffie-Hellman with ML-KEM. In particular, OpenMLS now supports the ciphersuite MLS_256_XWING_CHACHA20POLY1305_SHA256_Ed25519 with ciphersuite 0x004D. There is no IANA code-point for this ciphersuite yet, such that interoperability may not be guaranteed. We work with other implementers towards interoperability of this ciphersuite.</p>
<p>The implementation uses Cryspen‚Äôs <a href="https://cryspen.com/post/ml-kem-verification/">formally verified ML-KEM</a> and x25519 implementations from <a href="https://github.com/cryspen/libcrux/">libcrux</a>. The implementations are not only formally verified for correctness, secret independence, and memory safety, but also amongst the fastest implementations. Users should not notice any significant performance differences when using this new ciphersuite.
The threat of HNDL attackers requires applications to switch to post-quantum secure mechanisms now, just like <a href="https://signal.org/blog/pqxdh/">Signal</a> and <a href="https://security.apple.com/blog/imessage-pq3/">iMessage</a> did already. OpenMLS offers a simple way to achieve security against HNDL attackers and is ready to use.</p>
<h2 id="performance">Performance</h2>
<p>While the new ML-KEM mechanism is very efficient, it requires larger messages and because the ciphersuite used is hybrid (i.e. a combination of ML-KEM the classical x25519 KEM), the workload increases.</p>
<p>The following tables give an overview of the performance and message sizes.
One can clearly see an overhead from the post-quantum scheme.
While the computation complexity is not too high, and more efficient implementations of ML-KEM may be used, the communication complexity increases significantly due to the larger key and message sizes in ML-KEM.</p>
<h5 id="computation">Computation</h5>
<table>
  <thead>
      <tr>
          <th></th>
          <th>X-Wing + x25519</th>
          <th>x25519</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Create Key Package</td>
          <td>273.39 ¬µs</td>
          <td>138.24 ¬µs</td>
      </tr>
      <tr>
          <td>Create Welcome</td>
          <td>665.77 ¬µs</td>
          <td>366.23 ¬µs</td>
      </tr>
      <tr>
          <td>Join a group</td>
          <td>733.22 ¬µs</td>
          <td>313.37 ¬µs</td>
      </tr>
      <tr>
          <td>Self update</td>
          <td>650.77 ¬µs</td>
          <td>294.49 ¬µs</td>
      </tr>
  </tbody>
</table>
<h5 id="communication">Communication</h5>
<table>
  <thead>
      <tr>
          <th></th>
          <th>X-Wing + x25519</th>
          <th>x25519</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Key package size</td>
          <td>2669 Bytes</td>
          <td>299 Bytes</td>
      </tr>
      <tr>
          <td>Welcome size</td>
          <td>5457 Bytes</td>
          <td>716 Bytes</td>
      </tr>
      <tr>
          <td>Ratchet tree size</td>
          <td>4007 Bytes</td>
          <td>408 Bytes</td>
      </tr>
      <tr>
          <td>Self update size</td>
          <td>3954 Bytes</td>
          <td>495 Bytes</td>
      </tr>
  </tbody>
</table>
<h2 id="next-steps">Next Steps</h2>
<p>Using X-Wing as KEM in MLS is the easiest solution to achieve HNDL security for secure group messaging, or any use case that uses the state synchronization protocols specified in MLS.</p>
<p>However, X-Wing is designed as a drop-in KEM scheme with very conservative security guarantees. In the context of MLS, there may be more efficient ways to integrate HNDL protection, for example, by making use of more lightweight KEM combiners, or by other means specific to MLS. In the context of the MLS working group, we are actively discussing multiple proposals for improved HNDL protection. Once more promising candidates are available, we will publish a follow-up of this post.</p>
<p>A new version of OpenMLS will be released later this month, which will include this new, post-quantum secure, ciphersuite.</p>
]]></content:encoded></item><item><title>OpenMLS 0.5 released</title><link>https://blog.openmls.tech/posts/2023-07-20-v0_5-release/</link><pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2023-07-20-v0_5-release/</guid><description>&lt;p&gt;Today, we are releasing OpenMLS v0.5. This release has been a while in the making and covers substantial changes since the last release. We are grateful for &lt;a href="https://openmls.tech/blog/2022-10-19-update/"&gt;the support of the Sovereign Tech Fund&lt;/a&gt; towards this goal. These are some of the changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The implementation caught up with the latest changes in the protocol specification. The last version was roughly based on draft 12. Since then, the protocol has iteratively evolved all the way through draft 20. The library now implements the wire format of messages and mechanisms specified in &lt;a href="https://datatracker.ietf.org/doc/html/rfc9420"&gt;RFC 9420&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Extensive &lt;a href="https://github.com/mlswg/mls-implementations"&gt;interoperability testing&lt;/a&gt; has been done between OpenMLS, Cisco‚Äôs MLS++, and another closed-source MLS protocol implementation. The goal of this exercise was to validate the last set of changes in the specification and ascertain that all implementations implemented the specification correctly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="the-next-phase"&gt;The next phase&lt;/h1&gt;
&lt;p&gt;Until recently, the specification was a moving target and so was the implementation. Now that the specification is no longer subject to changes, the implementation can finally mature in terms of correctness, ease-of-use, and efficiency.
We would like OpenMLS to be as useful as possible to those who consider end-to-end encryption with MLS. We are ready to evolve the library in the following areas:&lt;/p&gt;</description><content:encoded><![CDATA[<p>Today, we are releasing OpenMLS v0.5. This release has been a while in the making and covers substantial changes since the last release. We are grateful for <a href="https://openmls.tech/blog/2022-10-19-update/">the support of the Sovereign Tech Fund</a> towards this goal. These are some of the changes:</p>
<ul>
<li>The implementation caught up with the latest changes in the protocol specification. The last version was roughly based on draft 12. Since then, the protocol has iteratively evolved all the way through draft 20. The library now implements the wire format of messages and mechanisms specified in <a href="https://datatracker.ietf.org/doc/html/rfc9420">RFC 9420</a>.</li>
<li>Extensive <a href="https://github.com/mlswg/mls-implementations">interoperability testing</a> has been done between OpenMLS, Cisco‚Äôs MLS++, and another closed-source MLS protocol implementation. The goal of this exercise was to validate the last set of changes in the specification and ascertain that all implementations implemented the specification correctly.</li>
</ul>
<h1 id="the-next-phase">The next phase</h1>
<p>Until recently, the specification was a moving target and so was the implementation. Now that the specification is no longer subject to changes, the implementation can finally mature in terms of correctness, ease-of-use, and efficiency.
We would like OpenMLS to be as useful as possible to those who consider end-to-end encryption with MLS. We are ready to evolve the library in the following areas:</p>
<ul>
<li>Stabilize the persistence format</li>
<li>Improve and harmonize the API</li>
<li>Improve efficiency</li>
<li>Support new platforms</li>
<li>Add optional features and extensions</li>
</ul>
<h1 id="looking-for-help">Looking for help?</h1>
<p>If you are looking to use OpenMLS in your project the OpenMLS team can offer professional help with consulting or with implementing. We can accelerate the development of the items listed above or offer a more bespoke solution. Drop us an email at <a href="mailto:hello@openmls.tech">hello@openmls.tech</a>.</p>
]]></content:encoded></item><item><title>OpenMLS Update</title><link>https://blog.openmls.tech/posts/2022-10-19-update/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2022-10-19-update/</guid><description>&lt;p&gt;&lt;em&gt;After a few months of silence, we are picking up work on OpenMLS again! üéâ&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://phnx.im/"&gt;Phoenix R&amp;amp;D&lt;/a&gt; and &lt;a href="https://www.cryspen.com"&gt;Cryspen&lt;/a&gt; join forces to bring OpenMLS closer to v1.0.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html"&gt;MLS protocol&lt;/a&gt; draft is in the IETF working group&amp;rsquo;s &lt;a href="https://mailarchive.ietf.org/arch/msg/mls/bOhxmpo70T-ikDd40OqQfst64gE/"&gt;last call&lt;/a&gt; and is thus
on track to become an RFC soon.
We want to make sure that OpenMLS is ready for wider adoption by the time the
RFC is ready.
To achieve this we start by catching up with all the changes to the protocol
(up to the current draft-16), improving test coverage of the code, and working
towards a more comprehensive test framework for interoperability.&lt;/p&gt;</description><content:encoded><![CDATA[<p><em>After a few months of silence, we are picking up work on OpenMLS again! üéâ</em></p>
<p><a href="https://phnx.im/">Phoenix R&amp;D</a> and <a href="https://www.cryspen.com">Cryspen</a> join forces to bring OpenMLS closer to v1.0.</p>
<p>The <a href="https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html">MLS protocol</a> draft is in the IETF working group&rsquo;s <a href="https://mailarchive.ietf.org/arch/msg/mls/bOhxmpo70T-ikDd40OqQfst64gE/">last call</a> and is thus
on track to become an RFC soon.
We want to make sure that OpenMLS is ready for wider adoption by the time the
RFC is ready.
To achieve this we start by catching up with all the changes to the protocol
(up to the current draft-16), improving test coverage of the code, and working
towards a more comprehensive test framework for interoperability.</p>
<p>We want to thank the <a href="https://sovereigntechfund.de/en">Sovereign Tech Fund</a> for <a href="https://sovereigntechfund.de/en/projects/openmls/">funding OpenMLS</a>
as the first project in its pilot round.</p>
<p>If you need support for MLS in general or OpenMLS in particular, please reach
out: <a href="mailto:hello@openmls.tech">hello@openmls.tech</a></p>
]]></content:encoded></item><item><title>OpenMLS v0.4 Release</title><link>https://blog.openmls.tech/posts/2022-02-28-v0_4-release/</link><pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2022-02-28-v0_4-release/</guid><description>&lt;p&gt;&lt;strong&gt;Today, we are excited to announce the release of &lt;a href="https://github.com/openmls/openmls/releases/tag/v0.4.0"&gt;v0.4 of OpenMLS&lt;/a&gt;! üéâ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Some time has passed since we wrote about our &lt;a href="https://openmls.tech/blog/2021-10-19-openmls-04-roadmap/"&gt;roadmap to v0.4&lt;/a&gt;. In this post, we want to provide some insight into what has happened in the development of OpenMLS generally, but also relative to the goals we included in the roadmap.&lt;/p&gt;
&lt;p&gt;Our high-level goal with v0.4 was to reach a state where we have an API stable enough and an implementation robust enough such that people interested in OpenMLS can start exploring it in the context of their own projects. However, this is not v1.0 and we can neither promise that the API won‚Äôt change in the future, nor do we advise using OpenMLS in production or indeed in any security-sensitive context. With this disclaimer out of the way, let‚Äôs see what has happened in these past months.&lt;/p&gt;</description><content:encoded><![CDATA[<p><strong>Today, we are excited to announce the release of <a href="https://github.com/openmls/openmls/releases/tag/v0.4.0">v0.4 of OpenMLS</a>! üéâ</strong></p>
<p>Some time has passed since we wrote about our <a href="https://openmls.tech/blog/2021-10-19-openmls-04-roadmap/">roadmap to v0.4</a>. In this post, we want to provide some insight into what has happened in the development of OpenMLS generally, but also relative to the goals we included in the roadmap.</p>
<p>Our high-level goal with v0.4 was to reach a state where we have an API stable enough and an implementation robust enough such that people interested in OpenMLS can start exploring it in the context of their own projects. However, this is not v1.0 and we can neither promise that the API won‚Äôt change in the future, nor do we advise using OpenMLS in production or indeed in any security-sensitive context. With this disclaimer out of the way, let‚Äôs see what has happened in these past months.</p>
<h2 id="-milestones-reached">üéØ Milestones Reached</h2>
<p>In our roadmap blog post, we documented a number of milestones that we were aiming for. Here is an overview of the milestones and how we reached them.</p>
<h3 id="-high-level-api-and-documentation">üìú High-Level API and Documentation</h3>
<p>After a lot of clean-up and re-design, OpenMLS now exposes the <code>MlsGroup</code> API, a high-level API that allows an application to create and manage a group, as well as parse, process, and validate MLS messages. The new API comes with the following changes:</p>
<ul>
<li>Major improvements to the documentation of the structs and functions we expose. The docs can be found <a href="https://docs.rs/crate/openmls/latest">here</a>.</li>
<li>The way that errors are exposed by OpenMLS was completely refactored, such that callers can now usefully branch on the errors thrown by a function.</li>
<li>Members of a group are now addressed using their <code>KeyPackageRef</code> (a hash of the key material representing the member in a given group) rather than their index in the group‚Äôs ratchet tree. This change required a major refactoring effort throughout our code-base, mirroring the preceding effort made on the spec-level to better abstract away the tree underlying MLS.</li>
</ul>
<h3 id="-user-manual">üìö User Manual</h3>
<p>OpenMLS now has a <a href="https://openmls.tech/book">user manual</a> that contains guidance on how to use the <code>MlsGroup</code> API to perform MLS group operations, along with some explicit examples.</p>
<h3 id="-crypto-provider">üîê Crypto Provider</h3>
<p>With v0.4 comes the <code>OpenMlsCryptoProvider</code> trait, that in turn wraps three other traits:</p>
<ul>
<li>the <code>OpenMlsCrypto</code> trait, on which OpenMLS relies for crypto implementations</li>
<li>the <code>OpenMlsKeyStore</code> trait, which can be used to store and retrieve cryptographic key material</li>
<li>the <code>OpenMlsRand</code> trait, which OpenMLS uses to generate randomness</li>
</ul>
<p>OpenMLS provides two implementations of the <code>OpenMlsCryptoProvider</code> trait, one based on the <a href="https://hacl-star.github.io/HaclValeEverCrypt.html">evercrypt</a> crypto provider and one on the <a href="https://github.com/RustCrypto">Rust Crypto</a> implementations. Both implementations rely on the <code>rand_chacha</code> crate for random number generation and a simple memory-based key store. See <a href="https://github.com/openmls/openmls/tree/main/traits">here</a> for more information on the traits and their implementations.</p>
<p>With the traits in place, anyone can bring their own implementations to use with OpenMLS.</p>
<h3 id="-supported-platforms">‚öôÔ∏è Supported Platforms</h3>
<p>OpenMLS is now compiled and tested for a number of 32 and 64-bit architectures:</p>
<table>
  <thead>
      <tr>
          <th>OS</th>
          <th>Target</th>
          <th>Build</th>
          <th>Tests</th>
          <th>CI</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>üêß</td>
          <td>x86_64-unknown-linux-gnu</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>üêß</td>
          <td>i686-unknown-linux-gnu</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>ü™ü</td>
          <td>x86_64-pc-windows-msvc</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>ü™ü</td>
          <td>i686-pc-windows-msvc</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>üçé</td>
          <td>x86_64-apple-darwin</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>üêß</td>
          <td>aarch64-unknown-linux-gnu</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>drone.io</td>
      </tr>
      <tr>
          <td>üçé</td>
          <td>aarch64-apple-darwin</td>
          <td>‚úÖ</td>
          <td>‚ùå</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>üêß</td>
          <td>aarch64-unknown-linux-gnu</td>
          <td>‚úÖ</td>
          <td>‚ùå</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>ü§ñ</td>
          <td>aarch64-linux-android</td>
          <td>‚úÖ</td>
          <td>‚ùå</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>üçé</td>
          <td>aarch64-apple-ios</td>
          <td>‚úÖ</td>
          <td>‚ùå</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>üçé</td>
          <td>aarch64-apple-ios-sim</td>
          <td>‚úÖ</td>
          <td>‚ùå</td>
          <td>GitHub</td>
      </tr>
      <tr>
          <td>üï∏Ô∏è</td>
          <td>wasm32-unknown-unknown</td>
          <td>‚úÖ</td>
          <td>‚ùå</td>
          <td>GitHub</td>
      </tr>
  </tbody>
</table>
<h3 id="-validation--authorization">üíå Validation &amp; Authorization</h3>
<p>Making use of Rust‚Äôs strong type system, the <code>CoreGroup</code> layer underneath the <code>MlsGroup</code> API not only ensures that every incoming MLS message is syntactically and semantically validated according to the MLS spec, but also that messages created using the <code>MlsGroup</code> API fulfill these requirements. Before any messages are finally applied to a group, the API exposes the message to the application along with all information required to make its own policy decisions.</p>
<p>All validation steps are <a href="https://openmls.tech/book/message_validation.html">indexed and documented</a>, as well as thoroughly tested.</p>
<h2 id="-still-not-finished-mls-keeps-improving">üèóÔ∏è Still Not Finished: MLS Keeps Improving</h2>
<p>For a while now, MLS has been ‚Äúclose to a working group last call‚Äù, but as implementations have matured and academic research on the protocol has progressed, issues and improvement proposals have been steadily trickling in. As a result, at the time of release of OpenMLS v0.4, there is still no working group last call and no additional draft of the specification has been released. Consequently, v0.4 is <a href="https://github.com/openmls/openmls/issues?q=is%3Aissue+is%3Aopen+label%3A%22mls-spec+change%22">not quite feature-complete</a>, but advances the implementation to draft 12+.</p>
<h2 id="-more-improvements-under-the-hood">üßëüèº‚Äçüîß More Improvements Under the Hood</h2>
<p>To achieve all of the milestones listed above, OpenMLS has seen many improvements under the hood.</p>
<ul>
<li>üå≥ TreeSync: The tree implementation supporting OpenMLS has been re-written in a style that allows a diff-merge process and that exposes a clear abstraction boundary between the ratchet tree and the rest of the implementation.</li>
<li>‚ö†Ô∏è Errors: OpenMLS now uses the <code>thiserror</code> crate throughout. Instead of module-wide error types, every function now returns an error enum that contains only the errors that can actually occur during the course of the function.</li>
<li>üò± Almost panic-free: Although not quite there yet, we have made a lot of progress in transitioning to a panic-free implementation, such that even in the event of an implementation bug we can ensure that OpenMLS functions will not panic.</li>
<li>‚è±Ô∏è Parallelization: The performance-critical functions of OpenMLS around the encryption of key material to other group members is now parallelized using the <code>rayon</code> crate.</li>
</ul>
<h2 id="-future-work">üíº Future Work</h2>
<p>The MLS specification is still in motion and there are many things that need to be improved before we can move towards the next OpenMLS release. If you have a suggestion, please let us know by joining our <a href="https://openmls.zulipchat.com">Zulip instance</a> or by filing an issue in our <a href="https://github.com/openmls/openmls">GitHub repo</a>. Or send us an email at <a href="mailto:hello@openmls.tech">hello@openmls.tech</a>.</p>
<h2 id="-metrics">üíØ Metrics</h2>
<p>Here are some data points that give an overview of our activity since the release of the roadmap in October 2021.</p>
<ul>
<li><a href="https://github.com/openmls/openmls/issues?q=is%3Aissue+is%3Aclosed+updated%3A2021-10-01..2022-02-28+">Closed issues since October 2021: 188</a></li>
<li><a href="https://github.com/openmls/openmls/pulls?q=is%3Apr+is%3Aclosed+updated%3A2021-10-01..2022-02-28+">Merged PRs since October 2021: 223</a></li>
<li><a href="https://github.com/openmls/openmls/compare/b99b23c8b76c3f1bb74ec7fef931b9b6c119cd85...v0.4.0">327 (update) commits</a></li>
</ul>
]]></content:encoded></item><item><title>OpenMLS v0.4 Roadmap</title><link>https://blog.openmls.tech/posts/2021-10-19-openmls-04-roadmap/</link><pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2021-10-19-openmls-04-roadmap/</guid><description>&lt;p&gt;It&amp;rsquo;s time for another update on OpenMLS because many things are happening behind the scenes.&lt;/p&gt;
&lt;p&gt;Today we are excited to announce a public roadmap for OpenMLS v0.4. This will not even be close to a v1.0 release because the &lt;a href="https://datatracker.ietf.org/doc/draft-ietf-mls-protocol/"&gt;spec&lt;/a&gt; is still not finished and it&amp;rsquo;s unclear how the library will be used. Nonetheless will v0.4 be a significant release with a mostly stable API and most functionality being implemented.&lt;/p&gt;
&lt;p&gt;Over the next five months we will fix the most pressing issues and make OpenMLS a usable MLS library for consumers to use. We are well aware that there is almost no experience with using MLS in a messaging product. (Cisco&amp;rsquo;s Webex is rolling out MLS for &lt;a href="https://www.btconferencing.com/downloads-library/services/webex-versions/t41/Webex_Latest_Channel_Customer_Monthly_Update_41.7.pdf"&gt;end-to-end encrypted video calls&lt;/a&gt; as part of their &lt;a href="https://www.cisco.com/c/en/us/solutions/collateral/collaboration/white-paper-c11-744553.html"&gt;zero-trust initiative&lt;/a&gt; right now.) The goal is therefore to offer a mostly stable API and complete feature set for consumers to start using it. However, we expect a significant feedback cycle to improve the APIs to make OpenMLS better suited for applications.&lt;/p&gt;</description><content:encoded><![CDATA[<p>It&rsquo;s time for another update on OpenMLS because many things are happening behind the scenes.</p>
<p>Today we are excited to announce a public roadmap for OpenMLS v0.4. This will not even be close to a v1.0 release because the <a href="https://datatracker.ietf.org/doc/draft-ietf-mls-protocol/">spec</a> is still not finished and it&rsquo;s unclear how the library will be used. Nonetheless will v0.4 be a significant release with a mostly stable API and most functionality being implemented.</p>
<p>Over the next five months we will fix the most pressing issues and make OpenMLS a usable MLS library for consumers to use. We are well aware that there is almost no experience with using MLS in a messaging product. (Cisco&rsquo;s Webex is rolling out MLS for <a href="https://www.btconferencing.com/downloads-library/services/webex-versions/t41/Webex_Latest_Channel_Customer_Monthly_Update_41.7.pdf">end-to-end encrypted video calls</a> as part of their <a href="https://www.cisco.com/c/en/us/solutions/collateral/collaboration/white-paper-c11-744553.html">zero-trust initiative</a> right now.) The goal is therefore to offer a mostly stable API and complete feature set for consumers to start using it. However, we expect a significant feedback cycle to improve the APIs to make OpenMLS better suited for applications.</p>
<h1 id="-the-road-to-v04">üõ£ The road to v0.4</h1>
<p>There are a number of high level goals we are tackling over the coming months.</p>
<p>You can follow the road to v0.4 on the <a href="https://github.com/openmls/openmls/milestone/3">Github milestone</a>.</p>
<h2 id="-validation--authorization">üíå Validation &amp; Authorization</h2>
<p>This milestone tackles two issues that aren&rsquo;t very well specified in the MLS specification; Validation and Authorization.</p>
<p>Validation ensures that group and application messages are &ldquo;valid&rdquo;. This includes a number of steps:</p>
<ul>
<li>Syntax validation to ensure that messages are well formed.</li>
<li>Semantic validation makes sure that messages are valid in a
given context. This includes signature verification, epoch number checks, etc.</li>
<li>Group policy validation establishes that the group policy, defining things like handshake type etc, is being adhered to.</li>
<li>The authentication service and policy validation checks to see whether syntactically and semantically correct messages should be adopted or dropped by answering questions such as: Is a member allowed to add another member? Is a member allowed to remove another member?</li>
</ul>
<h2 id="-supported-platforms">‚öôÔ∏è Supported Platforms</h2>
<p>The goal of OpenMLS is to support all relevant architectures and operating systems. This includes the major operating systems (Windows, macOS, Linux, Android, iOS) on all commonly used hardware architectures (x86, x86_64, arm64, arm32). Note that arm32 is a legacy platform and only supported on a best effort basis for old Android devices. Arm64 will be supported for all operating systems except Windows.</p>
<p>In addition OpenMLS can be used from JavaScript as a WebAssembly module. We don&rsquo;t have a JS API yet (<a href="https://github.com/openmls/openmls/issues/487">tracking issue #487</a>). If you are interested in contributing, this would be a great starting point.</p>
<h2 id="-documentation--apis">üìú Documentation &amp; APIs</h2>
<p>All high-level APIs that are interesting for consumers will be well documented and published.</p>
<p>Starting with v0.4 OpenMLS will adhere to <a href="https://semver.org/">semantic versioning</a> guidelines and increase the minor version number on breaking changes. Note however that OpenMLS will still be pre-1.0 and see a significant number of changes.</p>
<h3 id="-crypto-backends">üîê Crypto backends</h3>
<p>OpenMLS does not implement its own cryptographic primitives but uses other established libraries instead. In addition, MLS uses <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-hpke/">HPKE</a> for most of its asymmetric cryptography.</p>
<p>To allow flexible use cases OpenMLS will support the possibility for consumers to bring their own cryptographic primitives, random number generators, as well as a storage mechanisms for long term keys by implementing the respective trait.</p>
<h2 id="-feature-complete">üëèüèª Feature Complete</h2>
<p>OpenMLS will support all features described in <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-12.html">draft-12</a>. At this point we expect draft-12 to be the last draft before the <a href="https://www.ietf.org/about/glossary/?query=wglc">WGLC</a> such that the features implemented in v0.4 should be equivalent or very close to the final RFC.</p>
]]></content:encoded></item><item><title>OpenMLS Performance</title><link>https://blog.openmls.tech/posts/2021-05-18-openmls-first-benchmarks/</link><pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate><author>hello@openmls.tech (OpenMLS)</author><guid>https://blog.openmls.tech/posts/2021-05-18-openmls-first-benchmarks/</guid><description>&lt;p&gt;In this blog post, I explore how MLS&amp;rsquo; aspiration &lt;a href="https://datatracker.ietf.org/doc/charter-ietf-mls/"&gt;to be scalable&lt;/a&gt; manifests itself in OpenMLS.&lt;/p&gt;
&lt;p&gt;The charter in particular claims the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Resource requirements have good scaling in the size of the group (preferably sub-linear)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While performance can be theoretically analysed for MLS it is also interesting to see whether the performance goals hold up in a real implementation.
This of course only looks at a single implementation.
Nonetheless, I think that it gives a good impression on the actual performance of MLS implementations.
Particularly because OpenMLS at this point is not optimised but rather implements the MLS spec as is.&lt;/p&gt;</description><content:encoded><![CDATA[<p>In this blog post, I explore how MLS&rsquo; aspiration <a href="https://datatracker.ietf.org/doc/charter-ietf-mls/">to be scalable</a> manifests itself in OpenMLS.</p>
<p>The charter in particular claims the following:</p>
<blockquote>
<p>Resource requirements have good scaling in the size of the group (preferably sub-linear)</p>
</blockquote>
<p>While performance can be theoretically analysed for MLS it is also interesting to see whether the performance goals hold up in a real implementation.
This of course only looks at a single implementation.
Nonetheless, I think that it gives a good impression on the actual performance of MLS implementations.
Particularly because OpenMLS at this point is not optimised but rather implements the MLS spec as is.</p>
<h2 id="methodology">Methodology</h2>
<p>MLS is a pretty complex protocol with many moving parts.
It is therefore important to clearly define what is being measured and how.</p>
<p>First, all tests are done with the only mandatory cipher suite in MLS 1.0 MLS10_128_DHKEMX25519_AES128GCM_SHA256_Ed25519.
While other cipher suites obviously have different performance, the goal here is to investigate the general performance of MLS depending on the group size.
The exact cipher suite used is therefore irrelevant.</p>
<h3 id="measurements">Measurements</h3>
<p>The measurements here do not cover all possible messages in MLS.
Not all of them are fully supported by OpenMLS yet.
Pre-shared key, re-init, external-init, app-ack, and external proposals will be checked once they are implemented.
The measured messages nonetheless represent the core of the MLS protocol and should give a good idea of the general performance of the protocol.
We test performance of group creation, group join as well as the three basic messages update, add, and remove, and application messages.</p>
<p>All measurements except for the first two use one of the following set-ups:</p>
<ol>
<li>
<p><strong>Base</strong>: The group is created by a user.
All other participants are invited and each participant creates the group locally.
Then every participant sends an update message to the group and everyone else processes it.</p>
</li>
<li>
<p><strong>Bare:</strong> The group is created by a user.
All other participants are invited and each participant creates the group locally.
This creates an extremely sparse version of the underlying tree in MLS and is therefore interesting to look at.</p>
</li>
</ol>
<p>Measurements are run on different group sizes.
When running benchmarks with large groups such as 1000 participants a lot of memory is used in order to simulate all devices (up to 10 GB) such that larger groups are hard to simulate.
The chosen group sizes allow us to get a good idea how MLS performs depending on the group size.
We in particular test groups of the size 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 100, 200, 300, 400, 500, 1000.</p>
<h4 id="operations">Operations</h4>
<ul>
<li><strong>Group creation:</strong>
Creating a group involves creating the group, proposals and welcome messages for the other participants, and applying the commit.</li>
<li><strong>Join group:</strong>
Joining a group is equivalent to processing a welcome message to locally create the new group.</li>
<li><strong>Update messages:</strong>
Sending an update to a group involves creating a proposal, the corresponding commit and applying the commit.
When receiving an update message the commit is being processed.</li>
<li><strong>Adding a user:</strong>
When a new user is added to the group the add proposal and welcome message are created and the commit is locally applied by the adder.
When receiving a commit with an add proposal it is processed by the user.</li>
<li><strong>Removing a user:</strong>
When a user is removed from the group the remove proposal and commit are created and locally applied by the remover.
When receiving a commit with a remove proposal it is processed by the user.</li>
<li><strong>Application messages:</strong>
Sending an application message consists of creating the plaintext message and encrypting it for the group.
In order to receive an application message the user has to decrypt and parse the message.
We measure performance of a single message that is being sent and processed.
Note that the processing time of subsequent messages is not significantly different from the first one.</li>
</ul>
<h2 id="results">Results</h2>
<p>You can find the raw data and some more graphs in the <a href="https://docs.google.com/spreadsheets/d/1nZv8lpT28JctDVo4ARBLZCKcIdvo-h8cIyN3_dIedFU">OpenMLS performance spreadsheet</a>.</p>
<p>All measurements were performed on a laptop with Arch Linux, an Intel Core i7-4900MQ @ 2.80GHz and 16 GB memory.</p>
<h3 id="group-setup">Group setup</h3>
<p>As the following graph shows the time needed to create a group is linear in the number of participants added when creating the group.
The blue line shows the actual measurements while the magenta one is a trend line showing the linear relation.
This is what is to be expected because the performance is dominated by the creation of welcome messages, which have to be created for each member.</p>
<figure><a href="../images/group-creation.svg">
    <img loading="lazy" src="../../images/group-creation.svg"/> </a>
</figure>

<h3 id="join-group">Join group</h3>
<p>The performance of joining a group is linear in the group size because the information in the welcome message as well as the tree that is being processed when joining the group are linear in the number of group members.
Note that it is not logarithmic because the tree needs to be constructed.
This requires processing of each node in some way, which is linear in the group size.
The blue line again shows the actual measurements while the magenta one is a trend line for the linear relation.</p>
<figure><a href="../../images/join.svg">
    <img loading="lazy" src="../../images/join.svg"/> </a>
</figure>

<h3 id="update">Update</h3>
<p>Sending and processing updates are both sub-linear in the number of group members because the number of computations depend on the height of the tree in the <em>base</em> case.</p>
<figure><a href="../../images/update.svg">
    <img loading="lazy" src="../../images/update.svg"/> </a>
</figure>

<p>In the case of a very sparse tree, which we have in the <em>bare</em> case because every leaf only processed the welcome message, the performance of sending an update however is linear in the group size.
When creating a commit for an update proposal the sender has to include a path and refresh the private tree.
The following two flamegraphs show the difference between the base and the bare case.
While it doesn&rsquo;t show directly what&rsquo;s going on, it can be seen that in the base case (first flamegraph) the <code>new_with_keys</code> function requires a lot more time relative to the rest of the <code>replace_private_tree</code> function.
This is a strong indicator for where to look for the differences.</p>
<p><figure><a href="../images/send-update-base.png">
    <img loading="lazy" src="../../images/send-update-base.png"/> </a>
</figure>

<figure><a href="../images/send-update-bare.png">
    <img loading="lazy" src="../../images/send-update-bare.png"/> </a>
</figure>
</p>
<p>Looking at a tree with 300 leaves for example we have to encrypt 299 times (for every other leaf) in the case of a bare tree.
In a fully updated tree however only 9 encryptions are necessary, one for each level of the tree.
It is therefore expected that the performance of sending an update (with commit) in the bare case is linear in the group size.</p>
<h3 id="adding-a-user">Adding a user</h3>
<p>Looking at the performance of adding a user and processing an add commit in the following graph we can again see the linear growth in relation to the number of group members.
This is almost independent of the state of the tree.
The operations appear to be slightly more expensive in a fully updated tree though.</p>
<figure><a href="../images/add.svg">
    <img loading="lazy" src="../../images/add.svg"/> </a>
</figure>

<h3 id="removing-a-user">Removing a user</h3>
<p>Like updating, removing a user and processing a remove commit are linear in complexity in the base case as the following graph shows.
Removing in a very sparse tree is significantly more expensive than in a fully updated tree.
The reason is the same as for updating the tree.
The remove information has to be encrypted to all other remaining participants in the tree.</p>
<figure><a href="../images/remove.svg">
    <img loading="lazy" src="../../images/remove.svg"/> </a>
</figure>

<h3 id="application-messages">Application messages</h3>
<p>Sending and receiving application messages is essentially independent of the group size, as expected.
Receiving the first message within an epoch has a small overhead compared to subsequent message as seen in the second graph.
This should be negligible in practice though.</p>
<p><figure><a href="../images/application-message-send.svg">
    <img loading="lazy" src="../../images/application-message-send.svg"/> </a>
</figure>

<figure><a href="../images/application-message-receive.svg">
    <img loading="lazy" src="../../images/application-message-receive.svg"/> </a>
</figure>
</p>
<h2 id="analysis">Analysis</h2>
<p>First, the plain performance numbers tell us that the goal of the MLS charter of a protocol that scales well for large groups has been mostly.
Depending on the state of the tree some operations might take longer than expected.
However, this can be mitigated by the application ensuring that the tree is updated and shrunk regularly.
Notably, the real world performance appears to be consistent with the theoretical expectations.</p>
<h2 id="technical-background">Technical background</h2>
<p>The measurements are <em>not</em> done with any Rust benchmarking framework such as <a href="https://crates.io/crates/criterion">criterion</a>.
Due to the way criterion works there&rsquo;s significant <a href="https://github.com/bheisler/criterion.rs/issues/475">overhead in criterion</a>.
While the numbers in this post can be reliably reproduced a more thorough measurement framework</p>
<p>The flamegraphs are produced with <a href="https://crates.io/crates/pprof">pprof</a>, a simple to use CPU profiler for Rust.</p>
<p>All measurements were performed on <a href="https://github.com/openmls/openmls/tree/65030529e43716d482a6e57a432da5a388fd0a3c">this revision</a>.
To reproduce them check out the revision and run</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i in <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">8</span> <span style="color:#ae81ff">9</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">30</span> <span style="color:#ae81ff">40</span> <span style="color:#ae81ff">50</span> <span style="color:#ae81ff">100</span> <span style="color:#ae81ff">200</span> <span style="color:#ae81ff">300</span> <span style="color:#ae81ff">400</span> <span style="color:#ae81ff">500</span> 1000; <span style="color:#66d9ef">do</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>    cargo bench --bench group -- $i; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><h2 id="conclusion--future-work">Conclusion &amp; Future work</h2>
<p>Measuring performance of a protocol as complex as MLS is pretty difficult.
Without an application and elaborate test framework that can simulate many different scenarios it is only possible to get the basic numbers as shown here.
While they give a good indicator towards the performance of the MLS protocol they are insufficient to claim any performance of real applications that use MLS.</p>
<p>Nonetheless, the numbers show that the MLS protocol appears to allow for efficient, end-to-end-encrypted messaging in large groups.
Sending and receiving application messages is independent of the group size while group operations are sub-linear in the group size in most cases.</p>
<p>When OpenMLS is further developed and we have a messaging client using it another set of measurements should be performed with real world usage scenarios in mind in order to investigate whether the performance we have seen here translates to efficient group messaging in an application.
The MLS specification further leaves anything around authentication and authorization policies open to the application.
These might be complex procedures and impact the MLS performance as well.</p>
]]></content:encoded></item></channel></rss>