<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Taking Stock of Validation Checks | OpenMLS</title>
<meta name=keywords content="mls,openmls,validation,rfc9420"><meta name=description content="When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks&mldr; all kinds of vulnerabilities.
To give an example, you might remember the &ldquo;goto fail&rdquo; vulnerability, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the ServerKeyExchange message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn&rsquo;t just forget to do the check, it does demonstrate why these checks are important."><meta name=author content="Jan Winkelmann"><link rel=canonical href=https://blog.openmls.tech/posts/2024-09-30-taking-stock-of-validation-checks/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.openmls.tech/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.openmls.tech/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.openmls.tech/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.openmls.tech/apple-touch-icon.png><link rel=mask-icon href=https://blog.openmls.tech/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.openmls.tech/posts/2024-09-30-taking-stock-of-validation-checks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Taking Stock of Validation Checks"><meta property="og:description" content="When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks&mldr; all kinds of vulnerabilities.
To give an example, you might remember the &ldquo;goto fail&rdquo; vulnerability, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the ServerKeyExchange message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn&rsquo;t just forget to do the check, it does demonstrate why these checks are important."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.openmls.tech/posts/2024-09-30-taking-stock-of-validation-checks/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Taking Stock of Validation Checks"><meta name=twitter:description content="When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks&mldr; all kinds of vulnerabilities.
To give an example, you might remember the &ldquo;goto fail&rdquo; vulnerability, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the ServerKeyExchange message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn&rsquo;t just forget to do the check, it does demonstrate why these checks are important."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.openmls.tech/posts/"},{"@type":"ListItem","position":2,"name":"Taking Stock of Validation Checks","item":"https://blog.openmls.tech/posts/2024-09-30-taking-stock-of-validation-checks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Taking Stock of Validation Checks","name":"Taking Stock of Validation Checks","description":"When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks\u0026hellip; all kinds of vulnerabilities.\nTo give an example, you might remember the \u0026ldquo;goto fail\u0026rdquo; vulnerability, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the ServerKeyExchange message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn\u0026rsquo;t just forget to do the check, it does demonstrate why these checks are important.\n","keywords":["mls","openmls","validation","rfc9420"],"articleBody":"When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks… all kinds of vulnerabilities.\nTo give an example, you might remember the “goto fail” vulnerability, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the ServerKeyExchange message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn’t just forget to do the check, it does demonstrate why these checks are important.\nIn the context of MLS, consider what would happen if we didn’t do the check that validates the signature over FramedContent objects, which wrap the relevant parts of MLS messages to provide authentication. An attacker could change the sender field of FramedContent to a different member and we wouldn’t notice, because we don’t get an error when trying to validate the signature with that other member’s public key.\nThis is a drastic example of course, and it’s unlikely one would forget to implement this particular check. However, MLS is a large complex protocol and there are a lot of these checks in the MLS RFC that need to be done by OpenMLS (we counted 50 so far). The good news is that the RFC lays them all out. The bad news is that they are somewhat scattered across the document and there is no good overview.\nIn addition, the way the RFC abstracts away delivery and authentication also means that it is not always obvious whether a check would need to happen inside the client implementation (e.g. OpenMLS), the Delivery Service or the Authentication Service. This means that understanding whether a check has to be done inside or outside of OpenMLS is not always straightforward. And while in theory it is enough that all the checks are in the code, in practice it’s also important to test that all the checks are being performed, so they don’t accidentally get removed or circumvented in a refactor years later.\nWe knew we needed some sort of list or database of checks. This raised two questions: What sort of data do we want to keep, and how do we structure it? What is the format of the list?\nThe Data We Need Let’s look at the data first. The main information we want to capture are checks, and each check consists of an ID, a text quoted from and linking to the RFC text, and some way of referring to the code where the check is implemented and tested. We are still experimenting with that last part, but for now we have settled on keeping the modpath of the function we refer to, as well as a permalink to the specific part of the code. We also mention the check ID in the code, so that can also be searched for.\nMost validation checks belong to a group of checks that are performed together, and we would like to maintain that grouping, so each “check” is part of a “check set”. The check set also provides some context for the check. So a check set consists of another RFC quote (with link) and a list of checks.\nThe Format We Keep It In As for the formats, we wanted a uniform structure, and we want it to be relatively simple to update. And, maybe most importantly, we want to be able to look at and understand what we are missing. Let’s first look at what we thought didn’t work very well:\nA large text file (or md/html file, or a google doc) that we manually edit to render to a nice visual overview seems difficult to maintain The fact that some of the items each check carries are lists, makes using anything that resembles spreadsheets or CSV-files pretty awkward to use The obvious third choice would be a JSON file that contains an array of check sets. We could then write a tool that generates an HTML file providing an overview over the checks from the JSON. However, this would mean everything is in a single large file, and modifying that by hand seems pretty error-prone. YAML might be a bit nicer to write, but is also error-prone. It would be nice if we had a language that was a bit like JSON, but nicer to write and with strong types, to catch errors early.\nI had heard of the Dhall language before and while it always sounded interesting, I never had use for it. It’s a small programming language that mostly seems to be intended for generating config files. The idea is that it enforces termination and handling of all possible inputs. This means it can’t hang or error out because the program doesn’t handle an edge case. This seemed like an interesting option, and the fact that one of the main features of Dhall is that it can easily produce a JSON representation of the contained data, it would be easy to pivot to a different format if Dhall would turn out to not work well for us.\nWe followed a pretty boring structure: In one file we define the domain types (e.g. Check, CheckSet, ), in another file we generate HTML for the domain types. We also have a folder that contains one check set per file and a file that bundles all the check sets into a single place that can be processed. These all behave a bit like libraries. We then have a file that imports the check sets and the code generating the HTML and returns a string containing the dashboard, which looks like this.\nAn example Let’s go back to the check we looked at earlier. The check is part of a section that describes what need to be checked when validating a commit. In our dashboard, we made that whole section a check set, and at the time of writing it looks like this:\nValidation Dashboard The check set starts with quotes from the RFC and links to the places in the RFC that the quotes come from. It is followed by a table of checks. Each check has an identifier for the check, if we want to reference it in text. We then have the text from the RFC and a link to the specific paragraph of the RFC that contains the text. In the rightmost column we have a link to a search for the check ID in the OpenMLS repository on Github, some notes as well as references to the implementation of the check and tests for the check (if available). Links into the code show modpath of the linked function but link to the permalink to the specific lines of code where a check is implemented or tested. The pilcrows (¶) link to the check set or check itself, to make it easier to link it elsewere.\nFor example, the check set for commits contains check valn1203, which has a link to the RFC at exactly the right place, as well as links to the places where the check is implemented. We don’t have links to where we test that the check is done correctly, that’s why there are no test refs, and that’s also why the status of that check is Partial instead of Complete.\nThe nice thing about having the data in a machine-readable format is that we can also do other things with it. For example, we generate a bookmarklet (a little snippet of JS that is stored in a bookmark) that when it is clicked while browsing the RFC, it highlights all the parts of the RFC that have already been captured in the database. This helps with searching the RFC for checks we missed. In the future, we could also generate a dashboard that has its focus on the checks that are not completely implemented or tested yet. Try it, it’s here.\nLearnings Overall, Dhall works pretty well for us. There are some warts, such as not-very-helpful syntax error messages, the linter sometimes removing comments as well as documentation sometimes being a bit confusing and spread across several places, but it was reasonably easy to set up something that works and does the job reliably.\nAnother thing we haven’t completely figured out yet is how to best link into the code. Linking to source code lines at specific commits means we can link to specific lines, but also that links will quickly go out-of-date. Using Rust modpaths is more stable, in the sense that the path correctly identifies a piece of code across commits (unless you refactor). On the other hand, they are more granular (you can only reference functions) and there is no tooling for using them as hyperlinks. Also, it’s unclear how to deal with aliases and visibility. Because we were not sure what the right thing to do is here, we do both for now. On top of that, we added a link to search the source code for the ID of the check, to quickly find mentions in comments and function names. However, this requires being logged into Github and only works on the current main branch.\nNext Steps But now, the real work starts: Double-checking that we captured all the checks that we need to do, and making sure that we actually do all the checks, and properly test them. And while all that is going on, we are getting a better understanding of what we really need and how we can improve the dashboard.\nWe started adding missing checks and will continue doing so until all checks are implemented and tested.\nIn future we will also prove that all required checks have been performed. Stay tuned for more on this soon.\n","wordCount":"1655","inLanguage":"en","datePublished":"2024-09-30T00:00:00Z","dateModified":"2024-09-30T00:00:00Z","author":{"@type":"Person","name":"Jan Winkelmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.openmls.tech/posts/2024-09-30-taking-stock-of-validation-checks/"},"publisher":{"@type":"Organization","name":"OpenMLS","logo":{"@type":"ImageObject","url":"https://blog.openmls.tech/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.openmls.tech/ accesskey=h title="OpenMLS (Alt + H)">OpenMLS</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.openmls.tech/ title=Home><span>Home</span></a></li><li><a href=https://github.com/openmls/openmls title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Taking Stock of Validation Checks</h1><div class=post-meta><span title='2024-09-30 00:00:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;Jan Winkelmann</div></header><div class=post-content><p>When implementing cryptographic protocols, probably the most important thing is to not forget validating all inputs. Failing to do so can lead to inadvertant leakage of private information, state corruption, impersonation attacks&mldr; all kinds of vulnerabilities.</p><p>To give an example, you might remember <a href=https://www.imperialviolet.org/2014/02/22/applebug.html>the &ldquo;goto fail&rdquo; vulnerability</a>, a bug in the TLS implementation used in iOS. Here, the verification function of signatures sent along with the <code>ServerKeyExchange</code> message, which ties the server identity to the transcript and ephemeral key material. Due to a hard-to-spot slipup, it returned success early and never really checked the signature, which would allow an attacker to man-in-the-middle the connection. While in this case they didn&rsquo;t just <em>forget</em> to do the check, it does demonstrate why these checks are important.</p><p>In the context of MLS, consider what would happen if we didn&rsquo;t do the <a href=https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2-2.3>check</a> that validates the signature over <code>FramedContent</code> objects, which wrap the relevant parts of MLS messages to provide authentication. An attacker could change the sender field of <code>FramedContent</code> to a different member and we wouldn&rsquo;t notice, because we don&rsquo;t get an error when trying to validate the signature with that other member&rsquo;s public key.</p><p>This is a drastic example of course, and it&rsquo;s unlikely one would forget to implement this particular check. However, MLS is a large complex protocol and there are a lot of these checks in the MLS RFC that need to be done by OpenMLS (we counted 50 so far). The good news is that the RFC lays them all out. The bad news is that they are somewhat scattered across the document and there is no good overview.</p><p>In addition, the way the RFC abstracts away delivery and authentication also means that it is not always obvious whether a check would need to happen inside the client implementation (e.g. <a href=https://github.com/openmls/openmls>OpenMLS</a>), the Delivery Service or the Authentication Service. This means that understanding whether a check has to be done inside or outside of OpenMLS is not always straightforward. And while in theory it is enough that all the checks are in the code, in practice it&rsquo;s also important to test that all the checks are being performed, so they don&rsquo;t accidentally get removed or circumvented in a refactor years later.</p><p>We knew we needed some sort of list or database of checks. This raised two questions: What sort of data do we want to keep, and how do we structure it? What is the format of the list?</p><h1 id=the-data-we-need>The Data We Need<a hidden class=anchor aria-hidden=true href=#the-data-we-need>#</a></h1><p>Let&rsquo;s look at the data first. The main information we want to capture are checks, and each check consists of an ID, a text quoted from and linking to the RFC text, and some way of referring to the code where the check is implemented and tested. We are still experimenting with that last part, but for now we have settled on keeping the modpath of the function we refer to, as well as a permalink to the specific part of the code. We also mention the check ID in the code, so that can also be searched for.</p><p>Most validation checks belong to a group of checks that are performed together, and we would like to maintain that grouping, so each &ldquo;check&rdquo; is part of a &ldquo;check set&rdquo;. The check set also provides some context for the check. So a check set consists of another RFC quote (with link) and a list of checks.</p><h1 id=the-format-we-keep-it-in>The Format We Keep It In<a hidden class=anchor aria-hidden=true href=#the-format-we-keep-it-in>#</a></h1><p>As for the formats, we wanted a uniform structure, and we want it to be relatively simple to update. And, maybe most importantly, we want to be able to look at and understand what we are missing. Let&rsquo;s first look at what we thought didn&rsquo;t work very well:</p><ul><li>A large text file (or md/html file, or a google doc) that we manually edit to render to a nice visual overview seems difficult to maintain</li><li>The fact that some of the items each check carries are lists, makes using anything that resembles spreadsheets or CSV-files pretty awkward to use</li></ul><p>The obvious third choice would be a JSON file that contains an array of check sets. We could then write a tool that generates an HTML file providing an overview over the checks from the JSON. However, this would mean everything is in a single large file, and modifying that by hand seems pretty error-prone. YAML might be a bit nicer to write, but is also error-prone. It would be nice if we had a language that was a bit like JSON, but nicer to write and with strong types, to catch errors early.</p><p>I had heard of the <a href=https://dhall-lang.org/>Dhall language</a> before and while it always sounded interesting, I never had use for it. It&rsquo;s a small programming language that mostly seems to be intended for generating config files. The idea is that it enforces termination and handling of all possible inputs. This means it can&rsquo;t hang or error out because the program doesn&rsquo;t handle an edge case. This seemed like an interesting option, and the fact that one of the main features of Dhall is that it can easily produce a JSON representation of the contained data, it would be easy to pivot to a different format if Dhall would turn out to not work well for us.</p><p>We followed a pretty boring structure: In one file we define the domain types (e.g. <code>Check</code>, <code>CheckSet</code>, ), in another file we generate HTML for the domain types. We also have a folder that contains one check set per file and a file that bundles all the check sets into a single place that can be processed. These all behave a bit like libraries. We then have a file that imports the check sets and the code generating the HTML and returns a string containing the dashboard, which looks like <a href=https://validation.openmls.tech>this</a>.</p><h1 id=an-example>An example<a hidden class=anchor aria-hidden=true href=#an-example>#</a></h1><p>Let&rsquo;s go back to the <a href=https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2-2.3>check</a> we looked at earlier. The check is part of a <a href=https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2>section</a> that describes what need to be checked when validating a commit. In our dashboard, we made that whole section a <a href=https://validation.openmls.tech/#cs12>check set</a>, and at the time of writing it looks like this:</p><figure><a href=validation_dashboard.png><img loading=lazy src=validation_dashboard.png></a><figcaption>Validation Dashboard</figcaption></figure><p>The check set starts with quotes from the RFC and links to the places in the RFC that the quotes come from. It is followed by a table of checks. Each check has an identifier for the check, if we want to reference it in text. We then have the text from the RFC and a link to the specific paragraph of the RFC that contains the text. In the rightmost column we have a link to a search for the check ID in the OpenMLS repository on Github, some notes as well as references to the implementation of the check and tests for the check (if available). Links into the code show modpath of the linked function but link to the permalink to the specific lines of code where a check is implemented or tested. The pilcrows (¶) link to the check set or check itself, to make it easier to link it elsewere.</p><p>For example, the <a href=https://validation.openmls.tech/#cs12>check set for commits</a> contains check <a href=https://validation.openmls.tech/#valn1203>valn1203</a>, which has a link to the RFC at exactly the <a href=https://www.rfc-editor.org/rfc/rfc9420.html#section-12.4.2-2.3>right place</a>, as well as links to the <a href=https://github.com/openmls/openmls/blob/5067034708f2332b0dfd8d7d28eb6618fd38f4c7/openmls/src/group/mls_group/processing.rs#L273-L274>places</a> <a href=https://github.com/openmls/openmls/blob/5067034708f2332b0dfd8d7d28eb6618fd38f4c7/openmls/src/group/public_group/process.rs#L203-L204>where</a> the check is implemented. We don&rsquo;t have links to where we test that the check is done correctly, that&rsquo;s why there are no test refs, and that&rsquo;s also why the status of that check is <em>Partial</em> instead of <em>Complete</em>.</p><p>The nice thing about having the data in a machine-readable format is that we can also do other things with it. For example, we generate a bookmarklet (a little snippet of JS that is stored in a bookmark) that when it is clicked while browsing the RFC, it highlights all the parts of the RFC that have already been captured in the database. This helps with searching the RFC for checks we missed. In the future, we could also generate a dashboard that has its focus on the checks that are not completely implemented or tested yet. Try it, it&rsquo;s <a href=https://validation.openmls.tech/bookmarklet.html>here</a>.</p><h1 id=learnings>Learnings<a hidden class=anchor aria-hidden=true href=#learnings>#</a></h1><p>Overall, Dhall works pretty well for us. There are some warts, such as not-very-helpful syntax error messages, the linter sometimes removing comments as well as documentation sometimes being a bit confusing and spread across several places, but it was reasonably easy to set up something that works and does the job reliably.</p><p>Another thing we haven&rsquo;t completely figured out yet is how to best link into the code. Linking to source code lines at specific commits means we can link to specific lines, but also that links will quickly go out-of-date. Using Rust modpaths is more stable, in the sense that the path correctly identifies a piece of code across commits (unless you refactor). On the other hand, they are more granular (you can only reference functions) and there is no tooling for using them as hyperlinks. Also, it&rsquo;s unclear how to deal with aliases and visibility. Because we were not sure what the right thing to do is here, we do both for now. On top of that, we added a link to search the source code for the ID of the check, to quickly find mentions in comments and function names. However, this requires being logged into Github and only works on the current main branch.</p><h1 id=next-steps>Next Steps<a hidden class=anchor aria-hidden=true href=#next-steps>#</a></h1><p>But now, the real work starts: Double-checking that we captured all the checks that we need to do, and making sure that we actually do all the checks, and properly test them. And while all that is going on, we are getting a better understanding of what we really need and how we can improve the dashboard.</p><p>We started adding <a href=https://github.com/openmls/openmls/pull/1655>missing checks</a> and will continue doing so until all checks are implemented and tested.</p><p>In future we will also prove that all required checks have been performed. Stay tuned for more on this soon.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.openmls.tech/tags/mls/>Mls</a></li><li><a href=https://blog.openmls.tech/tags/openmls/>Openmls</a></li><li><a href=https://blog.openmls.tech/tags/validation/>Validation</a></li><li><a href=https://blog.openmls.tech/tags/rfc9420/>Rfc9420</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.openmls.tech/>OpenMLS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>